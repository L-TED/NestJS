CiCd ìë™í™” ë¦¬ì•¡íŠ¸ë…¸ë“œ êµ­ë¹„ìˆ˜ì—… ë‹˜ê³¼ ì¹´ì¹´ì˜¤í†¡ ëŒ€í™”
ì €ì¥í•œ ë‚ ì§œ : 2025-12-15 15:09:25

--------------- 2025ë…„ 12ì›” 14ì¼ ì¼ìš”ì¼ ---------------
[ì „ìˆ˜íš¨] [ì˜¤ì „ 9:49] ì˜ì„ ì´ ìƒì¼ì¶•í•˜
[ì „ìˆ˜íš¨] [ì˜¤ì „ 9:49] ë‚´ì¼ ì»¤í”¼ì‚¬ë‹¤ì¤„ê²Œ
[ì „ìˆ˜íš¨] [ì˜¤ì „ 9:49] ì•„ë‹ˆë‹¤ ëŠ¦ì ìêµ¬ì™€
[ì†ì •ìš°] [ì˜¤ì „ 10:36] ì´ëª¨í‹°ì½˜
[ì´ì˜ì² ] [ì˜¤ì „ 10:41] ì˜ì„ ë‹˜!! ìƒì¼ ì¶•í•˜ë“œë ¤ìš”!
[ì „ìƒì›] [ì˜¤í›„ 12:38] ìƒì¼ ì¶•í•˜ë“œë ¤ìš” ì˜ì„ ë‹˜!
[ì‹ ì—¬ì§„] [ì˜¤í›„ 1:04] ìƒì¼ ì¶•í•˜ë“œë ¤ìš”!! ì¦ê±°ìš´ ìƒì¼ ë³´ë‚´ì„¸ìš”!
[ìœ ë‚˜] [ì˜¤í›„ 1:23] ìƒì¼ ì¶•í•˜ë“œë ¤ìš”!!
[ì†ì˜ì„ ] [ì˜¤í›„ 2:18] ì¶•í•˜ ê°ì‚¬í•©ë‹ˆë” ë•ë¶„ì— ì¢‹ì€ìƒì¼ë³´ë‚´ìš”! ë‹¤ë“¤ ë³µë°›ìœ¼ì‹­ì…”ã…ã…ã…
--------------- 2025ë…„ 12ì›” 15ì¼ ì›”ìš”ì¼ ---------------
[Victor Park(Sinyool)] [ì˜¤ì „ 9:07] ì € ì¢€ ëŠ¦ì„ ê±° ê°™ìŠµë‹ˆë‹¤
[ì „ìˆ˜íš¨] [ì˜¤ì „ 9:21] ìœ ë¼ì‹œì•„
[ì´ì˜ì² ] [ì˜¤í›„ 12:55] import { Injectable } from '@nestjs/common';
import { CreateNotionDto } from './dto/create-notion.dto';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class NotionService {
  constructor(private config: ConfigService) {}

  async create(createNotionDto: CreateNotionDto) {
    const token = this.config.get('TOKEN');
    const page = this.config.get('PAGE');
    const url = this.config.get('APIURL');

    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };

    const body = JSON.stringify({
      parent: { type: 'page_id', page_id: page },
      title: [{ type: 'text', text: { content: 'í•™ìƒ ê´€ë¦¬ DB' } }],
      properties: {
        ì´ë¦„: { title: {} },
        ë‚ ì§œ: { date: {} },
        ì„±í–¥: {
          multi_select: {
            options: [
              { name: 'í™œë°œí•¨', color: 'yellow' },
              { name: 'ì¡°ìš©í•¨', color: 'blue' },
              { name: 'ì„±ì‹¤í•¨', color: 'green' },
              { name: 'ë§ì½', color: 'red' },
              { name: 'ë‚˜íƒœí•¨', color: 'gray' },
            ],
          },
        },
        ì¬ì ìƒíƒœ: {
          select: {
            options: [
              { name: 'ì¬í•™', color: 'green' },
              { name: 'íœ´í•™', color: 'yellow' },
              { name: 'í‡´í•™', color: 'red' },
              { name: 'ì¡¸ì—…', color: 'blue' },
            ],
          },
        },
      },
    });

    const result = await fetch(url, {
      method: 'POST',
      headers,
      body,
    });

    const data = await result.json();
    return data;
  }

  async addData() {
    const token = this.config.get('TOKEN');
    const url = this.config.get('PAGEURL');
    const database_id = '2ca69e4a2a848193b335fb5695d476f1';

    const students = [
      {
        name: 'ì´ì˜ì² ',
        registerDate: '2025-06-01',
        personality: ['í™œë°œí•¨', 'ì„±ì‹¤í•¨'],
      },
      {
        name: 'ì‹ ì—¬ì§„',
        registerDate: '2025-04-01',
        personality: ['ë‚˜íƒœí•¨', 'ì„±ì‹¤í•¨'],
      },
    ];

    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };

    await Promise.all(
      students.map((v) => {
        return fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            parent: {
              database_id: database_id,
            },
            properties: {
              ì´ë¦„: {
                title: [{ text: { content: v.name } }],
              },
              ë‚ ì§œ: {
                date: { start: v.registerDate },
              },
              ì„±í–¥: {
                multi_select: v.personality.map((p) => ({ name: p })),
              },
              ì¬ì ìƒíƒœ: {
                select: { name: 'ì¬í•™' },
              },
            },
          }),
        });
      }),
    );
    return 'ë';
  }
}

[ì „ìˆ˜íš¨] [ì˜¤í›„ 2:41] import { Injectable } from '@nestjs/common';
import { CreateNotionDto } from './dto/create-notion.dto';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs';
import * as path from 'path';
import { renderKakaoByDate } from 'src/kakao';
@Injectable()
export class NotionService {
  constructor(private config: ConfigService) {}

  async create(createNotionDto: CreateNotionDto) {
    const token = this.config.get('TOKEN');
    const page = this.config.get('PAGE');
    const url = this.config.get('APIURL');
    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };
    const body = JSON.stringify({
      parent: { type: 'page_id', page_id: page },
      title: [{ type: 'text', text: { content: 'í•™ìƒ ê´€ë¦¬ DB' } }],
      properties: {
        ì´ë¦„: { title: {} },
        ë‚ ì§œ: { date: {} },
        ì„±í–¥: {
          multi_select: {
            options: [
              { name: 'í™œë°œí•¨', color: 'yellow' },
              { name: 'ì¡°ìš©í•¨', color: 'blue' },
              { name: 'ì„±ì‹¤í•¨', color: 'green' },
              { name: 'ë§ì½', color: 'red' },
              { name: 'ë‚˜íƒœí•¨', color: 'gray' },
            ],
          },
        },
        ì¬ì ìƒíƒœ: {
          select: {
            options: [
              { name: 'ì¬í•™', color: 'green' },
              { name: 'íœ´í•™', color: 'yellow' },
              { name: 'í‡´í•™', color: 'red' },
              { name: 'ì¡¸ì—…', color: 'blue' },
            ],
          },
        },
      },
    });
    const result = await fetch(url, {
      method: 'POST',
      headers,
      body,
    });
    const data = await result.json();
    return data;
  }

  async createKakaoDb() {
    const token = this.config.get('TOKEN');
    const page = this.config.get('PAGE');
    const url = this.config.get('APIURL');
    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };
    const body = {
      parent: { type: 'page_id', page_id: page },
      title: [{ type: 'text', text: { content: 'ì¹´ì¹´ì˜¤í†¡ ì „ì²´ë‚´ìš© DB' } }],
      properties: {
        ì œëª©: { title: {} },
        ë‚ ì§œ: { date: {} },
        ë‚´ìš©: { rich_text: {} },
      },
    };

    const res = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });
    const json = await res.json();

    if (!res.ok)
      throw new Error(
        `Notion API Error ${res.status}: ${JSON.stringify(json)}`,
      );

    return json; // ì—¬ê¸°ì˜ json.idê°€ database_id
  }

  async addData() {
    const students = [
      {
        name: 'ì´ì˜ì² ',
        registerDate: '2025-06-01',
        personality: ['í™œë°œí•¨', 'ì„±ì‹¤í•¨'],
      },
      {
        name: 'ì‹ ì—¬ì§„',
        registerDate: '2025-04-01',
        personality: ['ë‚˜íƒœí•¨', 'ì„±ì‹¤í•¨'],
      },
    ];
    const token = this.config.get('TOKEN');
    const url = this.config.get('PAGEURL');
    const database_id = '2cac681810e0811c8bdcdb7576b0fd99';
    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };
    await Promise.all(
      students.map((v) => {
        return fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            parent: {
              database_id: database_id,
            },
            properties: {
              ì´ë¦„: {
                title: [{ text: { content: v.name } }],
              },
              ë‚ ì§œ: {
                date: { start: v.registerDate },
              },
              ì„±í–¥: {
                multi_select: v.personality.map((p) => ({ name: p })),
              },
              ì¬ì ìƒíƒœ: {
                select: { name: 'ì¬í•™' },
              },
            },
          }),
        }).then((v) => v.json());
      }),
    );
    return 'ë';
  }

  kakaoLog() {
    const filePath = path.join(__dirname, '../../group.txt');
    try {
      const data = fs.readFileSync(filePath, { encoding: 'utf8' });
      const pretty = renderKakaoByDate(data);
      return pretty;
    } catch (error) {
      console.error('Failed to read group.txt:', error);
      return null;
    }
  }
}

[ì „ìˆ˜íš¨] [ì˜¤í›„ 2:41] type KakaoMessage = {
  date: string; // "2025-12-15"
  dowKo?: string; // "ì›”ìš”ì¼" (ì›ë¬¸ì— ìˆìœ¼ë©´)
  sender: string; // "ì „ìˆ˜íš¨"
  ampm: 'ì˜¤ì „' | 'ì˜¤í›„';
  time: string; // "9:07"
  text: string; // ë©”ì‹œì§€ ë³¸ë¬¸(ê°œí–‰ í¬í•¨)
};

type KakaoDayGroup = {
  date: string;
  dowKo?: string;
  messages: KakaoMessage[];
};

const pad2 = (n: number) => String(n).padStart(2, '0');

/**
 * "2025ë…„ 12ì›” 15ì¼ ì›”ìš”ì¼" -> { date:"2025-12-15", dowKo:"ì›”ìš”ì¼" }
 */
const parseKakaoDateHeader = (
  line: string,
): { date: string; dowKo?: string } | null => {
  // --------------- 2025ë…„ 12ì›” 15ì¼ ì›”ìš”ì¼ ---------------
  const match =
    /-+\s*(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼\s*([ê°€-í£]+)?\s*-+/.exec(line);
  if (!match) return null;
  const y = match[1],
    mo = match[2],
    d = match[3],
    dowKo = match[4];
  return {
    date: `${y}-${pad2(+mo)}-${pad2(+d)}`,
    ...(dowKo && (dowKo.trim() ? { dowKo: dowKo.trim() } : {})),
  };
};

/**
 * "[ì´ì˜ì² ] [ì˜¤í›„ 12:55] ë‚´ìš©..." ë¼ì¸ íŒŒì‹±
 * - ë‚´ìš©ì´ ì—¬ëŸ¬ ì¤„ì´ë©´, ë‹¤ìŒ ë©”ì‹œì§€ ì‹œì‘ ì „ê¹Œì§€ ëˆ„ì 
 */
function isMessageStart(line: string) {
  return /^\[[^\]]+\]\s+\[(ì˜¤ì „|ì˜¤í›„)\s+\d{1,2}:\d{2}\]\s*/.test(line);
}

function parseMessageStart(line: string): {
  sender: string;
  ampm: 'ì˜¤ì „' | 'ì˜¤í›„';
  time: string;
  text: string;
} {
  const m = line.match(
    /^\[([^\]]+)\]\s+\[(ì˜¤ì „|ì˜¤í›„)\s+(\d{1,2}:\d{2})\]\s*(.*)$/,
  );
  if (!m) throw new Error('Invalid message line: ' + line);
  const [, sender, ampm, time, text] = m;
  return { sender: sender.trim(), ampm: ampm as any, time, text: text ?? '' };
}

/**
 * ë©”ì¸: TXT -> ë‚ ì§œë³„ ê·¸ë£¹(JSON)
 */
export function parseKakaoTxt(txt: string): KakaoDayGroup[] {
  const lines = txt.replace(/\r\n/g, '\n').split('\n');

  const groups: KakaoDayGroup[] = [];
  let currentDay: KakaoDayGroup | null = null;
  let currentMsg: KakaoMessage | null = null;

  const pushCurrentMsg = () => {
    if (currentDay && currentMsg) {
      currentMsg.text = currentMsg.text.replace(/[ \t]+$/gm, '').trimEnd();
      currentDay.messages.push(currentMsg);
      currentMsg = null;
    }
  };

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();

    // ë‚ ì§œ í—¤ë” ë°œê²¬
    const day = parseKakaoDateHeader(line);
    if (day) {
      pushCurrentMsg();
      currentDay = { ...day, messages: [] };
      groups.push(currentDay);
      continue;
    }

    // ë‚ ì§œ ì„¹ì…˜ ë°–(ìƒë‹¨ ë©”íƒ€ ë“±)ì€ ìŠ¤í‚µ
    if (!currentDay) continue;

    // ë©”ì‹œì§€ ì‹œì‘ ë¼ì¸
    if (isMessageStart(line)) {
      pushCurrentMsg();
      const m = parseMessageStart(line);
      currentMsg = {
        date: currentDay.date,
        dowKo: currentDay.dowKo,
        sender: m.sender,
        ampm: m.ampm,
        time: m.time,
        text: m.text ?? '',
      };
      continue;
    }

    // ë©”ì‹œì§€ ë³¸ë¬¸ ì´ì–´ë¶™ì´ê¸° (ì˜ˆ: ì½”ë“œë¸”ë¡/ê¸´ í…ìŠ¤íŠ¸ê°€ ë‹¤ìŒ ì¤„ë¡œ ê³„ì†ë¨)
    if (currentMsg) {
      currentMsg.text += (currentMsg.text ? '\n' : '') + rawLine; // ì›ë¬¸ ë“¤ì—¬ì“°ê¸° ìœ ì§€
    }
  }

  pushCurrentMsg();
  return groups;
}

/**
 * ë‚ ì§œë³„ ì˜ˆìœ ì¶œë ¥(ë Œë”ë§)
 * - ê¸°ë³¸: "YYYY-MM-DD (ì›”ìš”ì¼)" í—¤ë” + ë©”ì‹œì§€ ë¦¬ìŠ¤íŠ¸
 */
export function renderKakaoByDate(txt: string) {
  const groups = parseKakaoTxt(txt);

  // ì‚¬ì§„ í…ìŠ¤íŠ¸ë§Œ ì´ëª¨ì§€ë¡œ ëŒ€ì²´í•˜ëŠ” í•¨ìˆ˜
  function replacePhoto(text: string): string {
    return text
      .split('\n')
      .map((line) => (line.trim() === 'ì‚¬ì§„' ? 'ğŸ“·' : line))
      .join('\n');
  }

  return groups
    .map((g) => {
      const header = `ğŸ“… ${g.date}${g.dowKo ? ` (${g.dowKo})` : ''}`;
      const body = g.messages
        .map((m) => {
          const textWithPhoto = replacePhoto(m.text);
          return `- ${m.ampm} ${m.time} | ${m.sender}: ${textWithPhoto}`;
        })
        .join('\n');
      return `${header}\n${body}`;
    })
    .join('\n\n');
}

[ì „ìˆ˜íš¨] [ì˜¤í›„ 2:54] export type KakaoMessage = {
  date: string; // "2025-12-15"
  dowKo?: string; // "ì›”ìš”ì¼"
  sender: string; // "ì „ìˆ˜íš¨"
  ampm: 'ì˜¤ì „' | 'ì˜¤í›„';
  time: string; // "9:07"
  text: string; // ë©”ì‹œì§€ ë³¸ë¬¸(ê°œí–‰ í¬í•¨)
};

export type KakaoDayGroup = {
  date: string;
  dowKo?: string;
  messages: KakaoMessage[];
};

const pad2 = (n: number) => String(n).padStart(2, '0');

/**
 * ë‚ ì§œ í—¤ë” íŒŒì‹±
 * - "--------------- 2025ë…„ 12ì›” 15ì¼ ì›”ìš”ì¼ ---------------"
 * - "2025ë…„ 12ì›” 15ì¼ ì›”ìš”ì¼"
 */
export const parseKakaoDateHeader = (
  line: string,
): { date: string; dowKo?: string } | null => {
  const trimmed = line.trim();

  // í•˜ì´í”ˆ ìœ ë¬´/ê°œìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ ì¸ì‹
  const m = trimmed.match(
    /^(?:-+\s*)?(\d{4})ë…„\s*(\d{1,2})ì›”\s*(\d{1,2})ì¼(?:\s*([ê°€-í£]+))?(?:\s*-+)?$/,
  );
  if (!m) return null;

  const [, y, mo, d, dowKo] = m;
  const date = `${y}-${pad2(+mo)}-${pad2(+d)}`;

  return {
    date,
    ...(dowKo?.trim() ? { dowKo: dowKo.trim() } : {}),
  };
};

/**
 * ë©”ì‹œì§€ ì‹œì‘ ë¼ì¸ íŒë³„
 * - "[ì´ì˜ì² ] [ì˜¤í›„ 12:55] ë‚´ìš©..."
 * - ê³µë°±ì´ ì—¬ëŸ¬ ê°œ/ì—†ì–´ë„ ê²¬ë”¤
 */
export function isMessageStart(line: string) {
  return /^\[[^\]]+\]\s*\[(ì˜¤ì „|ì˜¤í›„)\s*\d{1,2}:\d{2}\]\s*/.test(line);
}

export function parseMessageStart(line: string): {
  sender: string;
  ampm: 'ì˜¤ì „' | 'ì˜¤í›„';
  time: string;
  text: string;
} {
  const m = line.match(
    /^\[([^\]]+)\]\s*\[(ì˜¤ì „|ì˜¤í›„)\s*(\d{1,2}:\d{2})\]\s*(.*)$/,
  );
  if (!m) throw new Error('Invalid message line: ' + line);

  const [, sender, ampm, time, text] = m;
  return {
    sender: sender.trim(),
    ampm: ampm as 'ì˜¤ì „' | 'ì˜¤í›„',
    time,
    text: text ?? '',
  };
}

/**
 * TXT -> ë‚ ì§œë³„ ê·¸ë£¹(JSON)
 * - ë©”ì‹œì§€ ë³¸ë¬¸ì€ "ì›ë¬¸ ë“¤ì—¬ì“°ê¸°" ìœ ì§€
 * - ë©”ì‹œì§€ ì¢…ë£Œ ì‹œ ìš°ì¸¡ ê³µë°± ì •ë¦¬
 */
export function parseKakaoTxt(txt: string): KakaoDayGroup[] {
  const lines = txt.replace(/\r\n/g, '\n').split('\n');

  const groups: KakaoDayGroup[] = [];
  let currentDay: KakaoDayGroup | null = null;
  let currentMsg: KakaoMessage | null = null;

  const pushCurrentMsg = () => {
    if (!currentDay || !currentMsg) return;

    // ì¤„ ë ê³µë°± ì œê±° + trailing newline ì •ë¦¬
    currentMsg.text = currentMsg.text.replace(/[ \t]+$/gm, '').trimEnd();
    currentDay.messages.push(currentMsg);
    currentMsg = null;
  };

  for (const rawLine of lines) {
    const line = rawLine.trimEnd();

    // 1) ë‚ ì§œ í—¤ë”
    const day = parseKakaoDateHeader(line);
    if (day) {
      pushCurrentMsg();
      currentDay = { ...day, messages: [] };
      groups.push(currentDay);
      continue;
    }

    // ë‚ ì§œ ì„¹ì…˜ ë°–ì€ ìŠ¤í‚µ
    if (!currentDay) continue;

    // 2) ë©”ì‹œì§€ ì‹œì‘
    if (isMessageStart(line)) {
      pushCurrentMsg();
      const m = parseMessageStart(line);
      currentMsg = {
        date: currentDay.date,
        dowKo: currentDay.dowKo,
        sender: m.sender,
        ampm: m.ampm,
        time: m.time,
        text: m.text ?? '',
      };
      continue;
    }

    // 3) ë©”ì‹œì§€ ë³¸ë¬¸ ì´ì–´ë¶™ì´ê¸°
    if (currentMsg) {
      currentMsg.text += (currentMsg.text ? '\n' : '') + rawLine; // ì›ë¬¸ ë“¤ì—¬ì“°ê¸° ìœ ì§€
    }
  }

  pushCurrentMsg();
  return groups;
}

/**
 * ì²¨ë¶€ í…ìŠ¤íŠ¸ ì¹˜í™˜(ì˜µì…˜)
 * - "ì‚¬ì§„" / "ë™ì˜ìƒ" / "íŒŒì¼" ê°™ì€ ë¼ì¸ì„ ë³´ê¸° ì¢‹ê²Œ ë°”ê¿ˆ
 */
export function normalizeAttachmentText(text: string): string {
  return text
    .split('\n')
    .map((line) => {
      const t = line.trim();
      if (t === 'ì‚¬ì§„') return 'ğŸ“· ì‚¬ì§„';
      if (t === 'ë™ì˜ìƒ') return 'ğŸï¸ ë™ì˜ìƒ';
      if (t === 'íŒŒì¼') return 'ğŸ“ íŒŒì¼';
      return line;
    })
    .join('\n');
}

/**
 * ë‚ ì§œë³„ ì˜ˆìœ ì¶œë ¥(ë Œë”ë§) - â€œë…¸ì…˜ ë³¸ë¬¸ì— ê·¸ëŒ€ë¡œ ë„£ê¸° ì¢‹ì€ ë¬¸ìì—´â€
 * - ë‚ ì§œ í—¤ë” + ë©”ì‹œì§€ë“¤ì„ ì‹œê°„ìˆœìœ¼ë¡œ ë‚˜ì—´
 */
export function renderKakaoByDate(txt: string) {
  const groups = parseKakaoTxt(txt);

  return groups
    .map((g) => {
      const header = `ğŸ“… ${g.date}${g.dowKo ? ` (${g.dowKo})` : ''}`;

      const body = g.messages
        .map((m) => {
          const normalized = normalizeAttachmentText(m.text);

          // ë©”ì‹œì§€ ë³¸ë¬¸ì´ ì—¬ëŸ¬ ì¤„ì´ë©´ ë³´ê¸° ì¢‹ê²Œ ë“¤ì—¬ì“°ê¸°
          const lines = normalized.split('\n');
          const first = lines[0] ?? '';
          const rest = lines
            .slice(1)
            .map((l) => `    ${l}`)
            .join('\n');

          const head = `- [${m.ampm} ${m.time}] ${m.sender}: ${first}`;
          return rest ? `${head}\n${rest}` : head;
        })
        .join('\n');

      return `${header}\n${body}`;
    })
    .join('\n\n');
}

/**
 * (ì¶”ê°€) â€œí•˜ë£¨ ì „ì²´ í…ìŠ¤íŠ¸â€ë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜
 * - í•˜ë£¨=1Row ì „ëµì— ìµœì í™”: rich_text/property ë˜ëŠ” page ë³¸ë¬¸ì— ë„£ê¸° ì¢‹ìŒ
 */
export function buildDayContent(group: KakaoDayGroup): string {
  return group.messages
    .map((m) => {
      const normalized = normalizeAttachmentText(m.text);
      return `[${m.ampm} ${m.time}] ${m.sender}\n${normalized}`.trim();
    })
    .join('\n\n');
}

[ì „ìˆ˜íš¨] [ì˜¤í›„ 2:54] import { Injectable } from '@nestjs/common';
import { CreateNotionDto } from './dto/create-notion.dto';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs';
import * as path from 'path';
import { parseKakaoTxt, renderKakaoByDate } from 'src/kakao';
@Injectable()
export class NotionService {
  constructor(private config: ConfigService) {}

  async create(createNotionDto: CreateNotionDto) {
    const token = this.config.get('TOKEN');
    const page = this.config.get('PAGE');
    const url = this.config.get('APIURL');
    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };
    const body = JSON.stringify({
      parent: { type: 'page_id', page_id: page },
      title: [{ type: 'text', text: { content: 'í•™ìƒ ê´€ë¦¬ DB' } }],
      properties: {
        ì´ë¦„: { title: {} },
        ë‚ ì§œ: { date: {} },
        ì„±í–¥: {
          multi_select: {
            options: [
              { name: 'í™œë°œí•¨', color: 'yellow' },
              { name: 'ì¡°ìš©í•¨', color: 'blue' },
              { name: 'ì„±ì‹¤í•¨', color: 'green' },
              { name: 'ë§ì½', color: 'red' },
              { name: 'ë‚˜íƒœí•¨', color: 'gray' },
            ],
          },
        },
        ì¬ì ìƒíƒœ: {
          select: {
            options: [
              { name: 'ì¬í•™', color: 'green' },
              { name: 'íœ´í•™', color: 'yellow' },
              { name: 'í‡´í•™', color: 'red' },
              { name: 'ì¡¸ì—…', color: 'blue' },
            ],
          },
        },
      },
    });
    const result = await fetch(url, {
      method: 'POST',
      headers,
      body,
    });
    const data = await result.json();
    return data;
  }

  async createKakaoDailyDb() {
    const token = this.config.get('TOKEN');
    const page = this.config.get('PAGE');
    const url = this.config.get('APIURL');

    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };

    // âœ… â€œí•˜ë£¨ = 1 Rowâ€ ìŠ¤í‚¤ë§ˆ
    const body = {
      parent: { type: 'page_id', page_id: page },
      title: [{ type: 'text', text: { content: 'ì¹´ì¹´ì˜¤í†¡ ì¼ìë³„ ë¡œê·¸ DB' } }],
      properties: {
        ì œëª©: { title: {} }, // âœ… Row í´ë¦­ìš©(í•„ìˆ˜). ë‚ ì§œ ë¬¸ìì—´ì„ ë„£ì„ ì»¬ëŸ¼
        ë‚ ì§œ: { date: {} }, // âœ… ì •ë ¬/í•„í„°ìš©
        ìš”ì¼: {
          select: {
            options: [
              { name: 'ì›”ìš”ì¼', color: 'blue' },
              { name: 'í™”ìš”ì¼', color: 'blue' },
              { name: 'ìˆ˜ìš”ì¼', color: 'blue' },
              { name: 'ëª©ìš”ì¼', color: 'blue' },
              { name: 'ê¸ˆìš”ì¼', color: 'blue' },
              { name: 'í† ìš”ì¼', color: 'purple' },
              { name: 'ì¼ìš”ì¼', color: 'purple' },
            ],
          },
        },
        ë‚´ìš©: { rich_text: {} }, // âœ… â€œê·¸ ë‚ ì§œ ì¹´í†¡ ì „ì²´ ë‚´ìš©â€ì„ ë„£ì„ ì»¬ëŸ¼
        ë©”ì‹œì§€ìˆ˜: { number: {} }, // âœ… ì„ íƒ: ê·¸ ë‚  ë©”ì‹œì§€ ê°œìˆ˜
      },
    };

    const res = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(body),
    });

    const json = await res.json();
    if (!res.ok) {
      throw new Error(
        `Notion API Error ${res.status}: ${JSON.stringify(json)}`,
      );
    }

    // json.id ê°€ database_id
    return json;
  }

  async addData() {
    const students = [
      {
        name: 'ì´ì˜ì² ',
        registerDate: '2025-06-01',
        personality: ['í™œë°œí•¨', 'ì„±ì‹¤í•¨'],
      },
      {
        name: 'ì‹ ì—¬ì§„',
        registerDate: '2025-04-01',
        personality: ['ë‚˜íƒœí•¨', 'ì„±ì‹¤í•¨'],
      },
    ];
    const token = this.config.get('TOKEN');
    const url = this.config.get('PAGEURL');
    const database_id = '2cac681810e0811c8bdcdb7576b0fd99';
    const headers = {
      Authorization: `Bearer ${token}`,
      'Notion-Version': '2022-06-28',
      'Content-Type': 'application/json',
    };
    await Promise.all(
      students.map((v) => {
        return fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            parent: {
              database_id: database_id,
            },
            properties: {
              ì´ë¦„: {
                title: [{ text: { content: v.name } }],
              },
              ë‚ ì§œ: {
                date: { start: v.registerDate },
              },
              ì„±í–¥: {
                multi_select: v.personality.map((p) => ({ name: p })),
              },
              ì¬ì ìƒíƒœ: {
                select: { name: 'ì¬í•™' },
              },
            },
          }),
        }).then((v) => v.json());
      }),
    );
    return 'ë';
  }

  async kakaoLog() {
    const filePath = path.join(__dirname, '../../group.txt');

    try {
      const raw = fs.readFileSync(filePath, { encoding: 'utf8' });

      // 1) TXT -> êµ¬ì¡°í™”(JSON)
      const groups = parseKakaoTxt(raw);

      // 2) Notion ì„¤ì •
      const token = this.config.get('TOKEN');
      const url = this.config.get('PAGEURL');
      const database_id = '2cac681810e08183a748ddea841c9ecb';

      const headers = {
        Authorization: `Bearer ${token}`,
        'Notion-Version': '2022-06-28',
        'Content-Type': 'application/json',
      };

      // 3) rich_text ì•ˆì „ ë¶„í• 
      const chunkRichText = (content: string, chunkSize = 1800) => {
        const chunks: { text: { content: string } }[] = [];
        for (let i = 0; i < content.length; i += chunkSize) {
          chunks.push({ text: { content: content.slice(i, i + chunkSize) } });
        }
        return chunks;
      };

      // 4) ë‚ ì§œ 1ê°œ = row 1ê°œë¡œ ì—…ë¡œë“œ (ë ˆì´íŠ¸ë¦¬ë°‹ ë°©ì§€ ìœ„í•´ ìˆœì°¨ ì²˜ë¦¬ ê¶Œì¥)
      const results: any[] = [];

      for (const g of groups) {
        // í•˜ë£¨ ì „ì²´ í…ìŠ¤íŠ¸ í•©ì¹˜ê¸° (ë©”ì‹œì§€ ë‹¨ìœ„ í•©ì¹¨)
        const dayText = g.messages
          .map((m) => `[${m.ampm} ${m.time}] ${m.sender}\n${m.text}`.trim())
          .join('\n\n');

        // âœ… DB ìŠ¤í‚¤ë§ˆì— ë§ì¶˜ properties
        const properties: any = {
          ì œëª©: { title: [{ text: { content: g.date } }] }, // â­ Row ì œëª©(í´ë¦­ ì‹œ ë³´ì„)
          ë‚ ì§œ: { date: { start: g.date } }, // â­ í•„ìˆ˜(ì •ë ¬/í•„í„°)
          ë‚´ìš©: { rich_text: chunkRichText(dayText) }, // â­ í•˜ë£¨ ì „ì²´ ë‚´ìš©
          // ì•„ë˜ 2ê°œëŠ” DBì— í•´ë‹¹ ì»¬ëŸ¼ì´ ìˆì„ ë•Œë§Œ ìœ ì§€
          ...(g.dowKo ? { ìš”ì¼: { select: { name: g.dowKo } } } : {}),
          ë©”ì‹œì§€ìˆ˜: { number: g.messages.length },
        };

        const body = {
          parent: { database_id },
          properties,
        };

        const res = await fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify(body),
        });

        const json = await res.json();
        if (!res.ok) {
          throw new Error(
            `Notion API Error ${res.status}: ${JSON.stringify(json)}`,
          );
        }

        results.push(json);
      }

      return { message: 'ë', insertedDays: results.length };
    } catch (error) {
      console.error('Failed to read/insert group.txt:', error);
      return null;
    }
  }
}

[ì „ìˆ˜íš¨] [ì˜¤í›„ 2:58] íŒŒì¼: group1.txt